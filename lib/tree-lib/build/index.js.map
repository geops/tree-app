{"version":3,"sources":["webpack://@geops/tree-lib/webpack/universalModuleDefinition","webpack://@geops/tree-lib/webpack/bootstrap","webpack://@geops/tree-lib/external \"lodash.intersection\"","webpack://@geops/tree-lib/external \"lodash.union\"","webpack://@geops/tree-lib/external \"lodash.difference\"","webpack://@geops/tree-lib/external \"lodash.xor\"","webpack://@geops/tree-lib/./src/info.js","webpack://@geops/tree-lib/./src/list.js","webpack://@geops/tree-lib/./src/locate.js","webpack://@geops/tree-lib/./src/project.js","webpack://@geops/tree-lib/./src/recommend.js","webpack://@geops/tree-lib/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","info","type","code","result","types","Error","find","emptyLists","byNumber","a","b","findForestType","forestType","f","nonresidents","treeType","nonresident","residents","list","location","transitionForestType","undefined","lists","entries","recommendations","transitionLists","union","intersection","sort","map","trees","filter","concat","checkTreeLayerHeight","height","ft","locate","ecogram","options","forestEcoregion","fe","altitudinalZone","locations","keys","id","ecograms","forestTypes","indicators","indicator","forestEcoregions","includes","altitudinalZoneForestEcoregion","az","length","altitudinalZones","indicatorForestTypes","it","reduce","ift","forestTypeGroup","group","treeLayerHeightMin","treeLayerHeightMax","coniferTreeHeightMax","deciduousTreeHeightMax","carbonateFine","carbonate","carbonateRock","geomorphologyRockBand","geomorphology","geomorphologyBlockyRockyStrong","geomorphologyBlockyRockyLittle","geomorphologyLimestonePavement","geomorphologyRocksModeratelyMoved","geomorphologyRocksStronglyMoved","geomorphologyRocksStabilised","reliefTypeCentralSlope","reliefType","reliefTypeHollow","reliefTypeDome","reliefTypePlateau","reliefTypeSteep","e","fields","fieldsConcat","x","y","Array","from","Set","altitudeList","reverse","getField","field","values","validate","v","valueNotInOptions","fieldOptions","project","targetAltitude","previousResult","altitudeIdx","indexOf","targetAltitudeIdx","projections","previous","slice","last","targetAltitudePointer","projection","unknown","split","push","projectionReducer","lastAltitudeIdx","targetAltitudinalZone","transitionAltitudinalZone","tl","tp","forEach","k","findIndex","removeDuplicates","foundItems","nestedArray","items","uniqueItems","difference","recommend","future","today1","today2","today3","today4","t123","p12","x1","x2","p3","p4","pAll","isFuture","isMulti","xor","version"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@geops/tree-lib\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@geops/tree-lib\"] = factory();\n\telse\n\t\troot[\"@geops/tree-lib\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","module.exports = require(\"lodash.intersection\");","module.exports = require(\"lodash.union\");","module.exports = require(\"lodash.difference\");","module.exports = require(\"lodash.xor\");","import types from '../data/types.json';\n\n/**\n * This function returns meta information about a given type and code.\n * If the code parameter is missing a list of all available codes is returned.\n * This meta information includes translations and type specific data.\n * See [data/types.json](https://github.com/geops/tree-lib/blob/master/data/types.json) for all available types and codes.\n *\n * @param {string} type A valid type.\n * @param {string} [code] A valid code for the given type.\n * @returns {object} Includes all meta information.\n */\nfunction info(type, code) {\n  let result = types[type];\n  if (!result) {\n    throw new Error(`${type} is not a valid type.`);\n  }\n\n  if (code) {\n    result = types[type].find((t) => t.code === code);\n\n    if (!result) {\n      throw new Error(`${type}.${code} is not a valid code.`);\n    }\n  }\n\n  return result;\n}\n\nexport default info;\n","import intersection from 'lodash.intersection';\nimport union from 'lodash.union';\n\nimport recommendations from '../data/recommendations.json';\nimport types from '../data/types.json';\n\nconst emptyLists = [[], [], [], []];\n\nconst byNumber = (a, b) => a > b;\nconst findForestType = (c) => types.forestType.find((f) => f.code === c);\nconst nonresidents = (c) =>\n  types.treeType.find((t) => t.code === c).nonresident;\nconst residents = (c) => !types.treeType.find((t) => t.code === c).nonresident;\n\n/**\n * This function lists all recommended tree types for the forest type at a given location.\n *\n * @param {object} location\n * @param {object} location.forestType Required code for forest type at current location.\n * @param {object} [location.transitionForestType] Optional code for transition forest type at current location.\n * @returns {array} Nested arrays of recommended tree type codes.\n */\nfunction list(location = {}) {\n  const { forestType, transitionForestType } = location;\n  if (!forestType) {\n    throw new Error(`forestType is missing`);\n  }\n\n  if (findForestType(forestType) === undefined) {\n    throw new Error(`${forestType} is not valid`);\n  }\n\n  const [, lists] = Object.entries(recommendations).find(\n    (t) => t[0] === forestType,\n  ) || [null, emptyLists];\n\n  if (transitionForestType) {\n    if (findForestType(transitionForestType) === undefined) {\n      throw new Error(`${transitionForestType} is not valid`);\n    }\n\n    const [, transitionLists] = Object.entries(recommendations).find(\n      (t) => t[0] === transitionForestType,\n    ) || [null, emptyLists];\n\n    lists[0] = union(\n      intersection(lists[0], transitionLists[0]),\n      intersection(lists[0], transitionLists[1]),\n    ).sort(byNumber);\n\n    lists[1] = union(\n      intersection(lists[0], transitionLists[2]),\n      intersection(lists[1], transitionLists[0]),\n      intersection(lists[1], transitionLists[1]),\n      intersection(lists[1], transitionLists[2]),\n      intersection(lists[2], transitionLists[0]),\n    ).sort(byNumber);\n\n    lists[2] = union(\n      intersection(lists[2], transitionLists[1]),\n      intersection(lists[2], transitionLists[2]),\n    ).sort(byNumber);\n\n    lists[3] = union(lists[3], transitionLists[3]).sort(byNumber);\n  }\n\n  return lists.map((trees) =>\n    trees.filter(residents).concat(trees.filter(nonresidents)),\n  );\n}\n\nexport default list;\n","import intersection from 'lodash.intersection';\n\nimport ecograms from '../data/ecograms.json';\nimport locations from '../data/locations.json';\n// import projections from '../data/projections.json';\nimport types from '../data/types.json';\n\nfunction checkTreeLayerHeight(height) {\n  return (ft) => ft.height && ft.height[0] <= height && ft.height[1] >= height;\n}\n\n/**\n * This function tries to locate the forest type for a given location.\n *\n * @param {object} location The current location.\n * @returns {object} Includes ecogram, forest types and options.\n */\nfunction locate(location = {}) {\n  const options = {\n    forestEcoregion: types.forestEcoregion.map((fe) => fe.code),\n  };\n  const { forestEcoregion, altitudinalZone } = location;\n  let ecogram;\n  if (locations[forestEcoregion]) {\n    options.altitudinalZone = Object.keys(locations[forestEcoregion]);\n    if (locations[forestEcoregion][altitudinalZone]) {\n      const id = locations[forestEcoregion][altitudinalZone];\n      ecogram = ecograms[id];\n    }\n  }\n\n  let forestTypes = types.forestType;\n  let indicators = types.indicator;\n  if (location.forestEcoregion) {\n    indicators = indicators.filter(\n      (i) => i.forestEcoregions && i.forestEcoregions.includes(forestEcoregion),\n    );\n    if (location.altitudinalZone) {\n      forestTypes = forestTypes.filter(\n        (ft) =>\n          ft.altitudinalZoneForestEcoregion &&\n          ft.altitudinalZoneForestEcoregion.filter(\n            ([az, fe]) => az === altitudinalZone && fe === forestEcoregion,\n          ).length > 0,\n      );\n    }\n  }\n  if (location.altitudinalZone) {\n    indicators = indicators.filter(\n      (i) => i.altitudinalZones && i.altitudinalZones.includes(altitudinalZone),\n    );\n  }\n  if (location.indicators && location.indicators.length > 0) {\n    const indicatorForestTypes = location.indicators\n      .map((i) => types.indicator.find((it) => it.code === i).forestTypes)\n      .reduce((ift, ft) => ift.concat(ft), []);\n    forestTypes = forestTypes.filter((ft) =>\n      indicatorForestTypes.includes(ft.code),\n    );\n  }\n  if (location.forestTypeGroup) {\n    forestTypes = forestTypes.filter(\n      (ft) => ft.group[location.forestTypeGroup] === true,\n    );\n  }\n  if (location.treeLayerHeightMin) {\n    forestTypes = forestTypes.filter(\n      checkTreeLayerHeight(location.treeLayerHeightMin),\n    );\n  }\n  if (location.treeLayerHeightMax) {\n    forestTypes = forestTypes.filter(\n      checkTreeLayerHeight(location.treeLayerHeightMax),\n    );\n  }\n  if (location.coniferTreeHeightMax) {\n    forestTypes = forestTypes.filter(\n      (ft) => ft.height && ft.height[2] >= location.coniferTreeHeightMax,\n    );\n  }\n  if (location.deciduousTreeHeightMax) {\n    forestTypes = forestTypes.filter(\n      (ft) => ft.height && ft.height[3] >= location.deciduousTreeHeightMax,\n    );\n  }\n  if (location.carbonateFine) {\n    forestTypes = forestTypes.filter((ft) => ft.carbonate[0] === true);\n  }\n  if (location.carbonateRock) {\n    forestTypes = forestTypes.filter((ft) => ft.carbonate[1] === true);\n  }\n  if (location.geomorphologyRockBand) {\n    forestTypes = forestTypes.filter((ft) => ft.geomorphology[0] === true);\n  }\n  if (location.geomorphologyBlockyRockyStrong) {\n    forestTypes = forestTypes.filter((ft) => ft.geomorphology[1] === true);\n  }\n  if (location.geomorphologyBlockyRockyLittle) {\n    forestTypes = forestTypes.filter((ft) => ft.geomorphology[2] === true);\n  }\n  if (location.geomorphologyLimestonePavement) {\n    forestTypes = forestTypes.filter((ft) => ft.geomorphology[3] === true);\n  }\n  if (location.geomorphologyRocksModeratelyMoved) {\n    forestTypes = forestTypes.filter((ft) => ft.geomorphology[4] === true);\n  }\n  if (location.geomorphologyRocksStronglyMoved) {\n    forestTypes = forestTypes.filter((ft) => ft.geomorphology[5] === true);\n  }\n  if (location.geomorphologyRocksStabilised) {\n    forestTypes = forestTypes.filter((ft) => ft.geomorphology[6] === true);\n  }\n  if (location.reliefTypeCentralSlope) {\n    forestTypes = forestTypes.filter((ft) => ft.reliefType[0] === true);\n  }\n  if (location.reliefTypeHollow) {\n    forestTypes = forestTypes.filter((ft) => ft.reliefType[1] === true);\n  }\n  if (location.reliefTypeDome) {\n    forestTypes = forestTypes.filter((ft) => ft.reliefType[2] === true);\n  }\n  if (location.reliefTypePlateau) {\n    forestTypes = forestTypes.filter((ft) => ft.reliefType[3] === true);\n  }\n  if (location.reliefTypeSteep) {\n    forestTypes = forestTypes.filter((ft) => ft.reliefType[4] === true);\n  }\n  forestTypes = forestTypes.map((ft) => ft.code);\n  options.indicator = indicators.map((i) => i.code);\n\n  if (ecogram) {\n    ecogram = ecogram.map((e) => {\n      const a = intersection(e.f, forestTypes).length > 0; // active\n      return { ...e, a };\n    });\n  }\n\n  return { ecogram, forestTypes, options };\n}\n\nexport default locate;\n","import projections from '../data/projections.json';\nimport types from '../data/types.json';\n\nconst fields = [\n  'forestEcoregion',\n  'altitudinalZone',\n  'forestType',\n  'slope',\n  'additional',\n  'silverFirArea',\n  'relief',\n];\nconst fieldsConcat = ['slope', 'additional', 'silverFirArea', 'relief'];\nconst concat = (x, y) =>\n  Array.from(new Set((x || []).concat(y))).sort((a, b) => a - b);\n\nconst altitudeList = types.altitudinalZone\n  .map((az) => az.code)\n  .sort((a, b) => a - b)\n  .reverse();\n\nconst getField = (field, location) => ({\n  field,\n  value: location[field],\n  values: types[field],\n});\n\nconst validate = (field, value, values) => {\n  if (value && values && values.find((v) => v.code === value) === undefined) {\n    throw new Error(`${value} for ${field} is not valid.`);\n  }\n};\nconst valueNotInOptions = (value, fieldOptions) =>\n  value && fieldOptions && fieldOptions.find((v) => v === value) === undefined;\n\nfunction projectionReducer(location, targetAltitudePointer, result) {\n  const { options } = result;\n  let projection = projections;\n  for (let i = 0; i < fields.length; i += 1) {\n    const { field, value, values } = getField(fields[i], location);\n    validate(field, value, values);\n\n    options[field] = fieldsConcat.includes(field)\n      ? concat(options[field], Object.keys(projection))\n      : options[field] || Object.keys(projection);\n\n    if (value && projection[value]) {\n      projection = projection[value];\n    } else if (projection.unknown) {\n      // Handle optional fields.\n      projection = projection.unknown;\n    } else if (valueNotInOptions(value, options[field])) {\n      // Do not return location values if no projection was found.\n      return { ...result, options };\n    } else if (fieldsConcat.includes(field)) {\n      // Fall back to first projection for secondary fields.\n      const first = Object.keys(projection)[0];\n      projection = projection[first];\n    } else {\n      // Location does not provide any more values for conditions.\n      break;\n    }\n  }\n\n  if (typeof projection === 'string') {\n    const [altitudinalZone, forestType] = projection.split(':');\n    if (altitudeList.indexOf(altitudinalZone) <= targetAltitudePointer) {\n      result.projections.push({ altitudinalZone, forestType });\n    }\n  }\n\n  return { ...result, options };\n}\n\n/**\n * This function projects the forest type for a given location into the future.\n *\n * @param {object} location The current location.\n * @param {string} targetAltitude Code for target altitudinal zone.\n * @param {object} [previousResult] Only for internal use.\n * @returns {object} Includes projections and options.\n */\nfunction project(location = {}, targetAltitude, previousResult) {\n  const altitudeIdx = altitudeList.indexOf(location.altitudinalZone);\n  const targetAltitudeIdx = altitudeList.indexOf(targetAltitude);\n  let result = previousResult || { options: {}, projections: [] };\n\n  validate('targetAltitudinalZone', targetAltitude, types.altitudinalZone);\n\n  const previous = result.projections.slice(-1)[0];\n  result = projectionReducer(location, targetAltitudeIdx, result);\n  const last = result.projections.slice(-1)[0];\n  const lastAltitudeIdx = last && altitudeList.indexOf(last.altitudinalZone);\n\n  if (previous && previous.altitudinalZone === last.altitudinalZone) {\n    // Could not find projection to targetAltitude\n    result.projections = [];\n  } else if (lastAltitudeIdx < targetAltitudeIdx) {\n    result = project({ ...location, ...last }, targetAltitude, result);\n  }\n\n  if (result && location.forestType && altitudeIdx !== -1) {\n    result.options.targetAltitudinalZone = altitudeList.slice(altitudeIdx + 1);\n  }\n\n  if (location.transitionForestType) {\n    const { transitionForestType, transitionAltitudinalZone, ...tl } = location;\n    tl.forestType = transitionForestType;\n    tl.altitudinalZone = transitionAltitudinalZone;\n    const { options, projections: tp } = project(tl, targetAltitude);\n    Object.entries(options).forEach(([k, v]) => {\n      if (fieldsConcat.includes(k)) {\n        result.options[k] = concat(result.options[k], v);\n      }\n    });\n    result.projections = result.projections.map((p) => {\n      const i = tp.findIndex((t) => t.altitudinalZone === p.altitudinalZone);\n      return { ...p, transitionForestType: tp[i] && tp[i].forestType };\n    });\n  }\n\n  // Replace alphanumeric sorting with custom sorting based on database export\n  if (result.options.forestType) {\n    result.options.forestType = types.forestType\n      .filter((ft) => result.options.forestType.includes(ft.code))\n      .map((ft) => ft.code);\n  }\n\n  return result;\n}\n\nexport default project;\n","import difference from 'lodash.difference';\nimport intersection from 'lodash.intersection';\nimport union from 'lodash.union';\nimport xor from 'lodash.xor';\n\nimport list from './list';\n\nconst removeDuplicates = (...nestedArray) => {\n  const foundItems = [];\n  return nestedArray.map((items) => {\n    const uniqueItems = difference(items, foundItems);\n    foundItems.push(...items);\n    return uniqueItems;\n  });\n};\n\n/**\n * This function recommends tree types based on a location and list of projections. Call this function with the result of the `project()` function.\n *\n * @param {object} location The current location.\n * @param {array} projections The result of the `project()` function.\n * @param {boolean} [future] Optional flag to include tree types for the future.\n * @returns {array} Nested arrays of recommended tree type codes.\n */\nfunction recommend(location = {}, projections = [], future = false) {\n  if (!location.forestType) {\n    throw new Error('location.forestType is required');\n  }\n  if (projections.reduce((c, p) => (p.forestType ? c + 1 : null), 0) < 1) {\n    throw new Error('at least 1 projected forestType is required');\n  }\n  if (future && typeof future !== 'boolean') {\n    throw new Error(`expected boolean type for future flag`);\n  }\n\n  const [today1, today2, today3, today4] = list(location);\n  const t123 = union(today1, today2, today3);\n  const p = projections.map((x) => list(x));\n  const p12 = p.map(([x1, x2]) => union(x1, x2));\n  const p3 = p.map(([, , x3]) => x3);\n  const p4 = p.map(([, , , x4]) => x4);\n  const pAll = p.map((x) => union(...x));\n  const isFuture = (x) => (future ? x : []);\n  const isMulti = (x) => (projections.length > 1 ? x : []);\n\n  return removeDuplicates(\n    intersection(t123, intersection(...p12)), //         Level 1\n    isMulti(intersection(t123, xor(...p12))), //         Level 2\n    isFuture(difference(intersection(...p12), t123)), // Level 3\n    isFuture(isMulti(difference(xor(...p12), t123))), // Level 4\n    intersection(t123, intersection(...p3)), //          Level 5\n    isMulti(intersection(t123, xor(...p3))), //          Level 6\n    isFuture(difference(intersection(...p3), t123)), //  Level 7\n    isFuture(isMulti(difference(xor(...p3), t123))), //  Level 8\n    difference(t123, union(...pAll)), //                 Level 9\n    union(today4, ...p4), //                             Level 10\n  );\n}\n\nexport default recommend;\n","import { version } from '../package.json';\n\nexport { default as info } from './info';\nexport { default as list } from './list';\nexport { default as locate } from './locate';\nexport { default as project } from './project';\nexport { default as recommend } from './recommend';\n\nexport default { version };\n"],"sourceRoot":""}