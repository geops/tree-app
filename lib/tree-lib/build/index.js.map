{"version":3,"sources":["webpack://@geops/tree-lib/webpack/universalModuleDefinition","webpack://@geops/tree-lib/webpack/bootstrap","webpack://@geops/tree-lib/external \"lodash.intersection\"","webpack://@geops/tree-lib/external \"lodash.union\"","webpack://@geops/tree-lib/external \"lodash.difference\"","webpack://@geops/tree-lib/external \"lodash.xor\"","webpack://@geops/tree-lib/./src/info.js","webpack://@geops/tree-lib/./src/list.js","webpack://@geops/tree-lib/./src/locate.js","webpack://@geops/tree-lib/./src/project.js","webpack://@geops/tree-lib/./src/recommend.js","webpack://@geops/tree-lib/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","info","type","code","result","types","Error","find","emptyLists","byNumber","a","b","findForestType","forestType","f","nonresidents","treeType","nonresident","residents","list","location","transitionForestType","undefined","lists","entries","recommendations","transitionLists","union","intersection","sort","map","trees","filter","concat","checkTreeLayerHeight","height","ft","locate","ecogram","indicator","options","forestEcoregion","keys","locations","altitudinalZone","id","ecograms","forestTypes","indicators","forestTypeGroup","group","treeLayerHeightMin","treeLayerHeightMax","coniferTreeHeightMax","deciduousTreeHeightMax","e","length","fields","fieldsConcat","x","y","Array","from","Set","altitudeList","az","reverse","getField","field","values","validate","v","valueNotInOptions","fieldOptions","project","targetAltitude","previousResult","altitudeIdx","indexOf","targetAltitudeIdx","projections","previous","slice","last","targetAltitudePointer","projection","includes","unknown","split","push","projectionReducer","lastAltitudeIdx","targetAltitudinalZone","transitionAltitudinalZone","tl","tp","forEach","k","findIndex","removeDuplicates","foundItems","nestedArray","items","uniqueItems","difference","recommend","future","reduce","today1","today2","today3","today4","t123","p12","x1","x2","p3","p4","pAll","isFuture","isMulti","xor","version"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@geops/tree-lib\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@geops/tree-lib\"] = factory();\n\telse\n\t\troot[\"@geops/tree-lib\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","module.exports = require(\"lodash.intersection\");","module.exports = require(\"lodash.union\");","module.exports = require(\"lodash.difference\");","module.exports = require(\"lodash.xor\");","import types from '../data/types.json';\n\n/**\n * This function returns meta information about a given type and code.\n * If the code parameter is missing a list of all available codes is returned.\n * This meta information includes translations and type specific data.\n * See [data/types.json](https://github.com/geops/tree-lib/blob/master/data/types.json) for all available types and codes.\n *\n * @param {string} type A valid type.\n * @param {string} [code] A valid code for the given type.\n * @returns {object} Includes all meta information.\n */\nfunction info(type, code) {\n  let result = types[type];\n  if (!result) {\n    throw new Error(`${type} is not a valid type.`);\n  }\n\n  if (code) {\n    result = types[type].find((t) => t.code === code);\n\n    if (!result) {\n      throw new Error(`${type}.${code} is not a valid code.`);\n    }\n  }\n\n  return result;\n}\n\nexport default info;\n","import intersection from 'lodash.intersection';\nimport union from 'lodash.union';\n\nimport recommendations from '../data/recommendations.json';\nimport types from '../data/types.json';\n\nconst emptyLists = [[], [], [], []];\n\nconst byNumber = (a, b) => a > b;\nconst findForestType = (c) => types.forestType.find((f) => f.code === c);\nconst nonresidents = (c) =>\n  types.treeType.find((t) => t.code === c).nonresident;\nconst residents = (c) => !types.treeType.find((t) => t.code === c).nonresident;\n\n/**\n * This function lists all recommended tree types for the forest type at a given location.\n *\n * @param {object} location\n * @param {object} location.forestType Required code for forest type at current location.\n * @param {object} [location.transitionForestType] Optional code for transition forest type at current location.\n * @returns {array} Nested arrays of recommended tree type codes.\n */\nfunction list(location = {}) {\n  const { forestType, transitionForestType } = location;\n  if (!forestType) {\n    throw new Error(`forestType is missing`);\n  }\n\n  if (findForestType(forestType) === undefined) {\n    throw new Error(`${forestType} is not valid`);\n  }\n\n  const [, lists] = Object.entries(recommendations).find(\n    (t) => t[0] === forestType,\n  ) || [null, emptyLists];\n\n  if (transitionForestType) {\n    if (findForestType(transitionForestType) === undefined) {\n      throw new Error(`${transitionForestType} is not valid`);\n    }\n\n    const [, transitionLists] = Object.entries(recommendations).find(\n      (t) => t[0] === transitionForestType,\n    ) || [null, emptyLists];\n\n    lists[0] = union(\n      intersection(lists[0], transitionLists[0]),\n      intersection(lists[0], transitionLists[1]),\n    ).sort(byNumber);\n\n    lists[1] = union(\n      intersection(lists[0], transitionLists[2]),\n      intersection(lists[1], transitionLists[0]),\n      intersection(lists[1], transitionLists[1]),\n      intersection(lists[1], transitionLists[2]),\n      intersection(lists[2], transitionLists[0]),\n    ).sort(byNumber);\n\n    lists[2] = union(\n      intersection(lists[2], transitionLists[1]),\n      intersection(lists[2], transitionLists[2]),\n    ).sort(byNumber);\n\n    lists[3] = union(lists[3], transitionLists[3]).sort(byNumber);\n  }\n\n  return lists.map((trees) =>\n    trees.filter(residents).concat(trees.filter(nonresidents)),\n  );\n}\n\nexport default list;\n","import intersection from 'lodash.intersection';\n\nimport ecograms from '../data/ecograms.json';\n// import indicators from '../data/indicators.json';\nimport locations from '../data/locations.json';\nimport types from '../data/types.json';\n\nfunction checkTreeLayerHeight(height) {\n  return (ft) => ft.height && ft.height[0] <= height && ft.height[1] >= height;\n}\n\n/**\n * This function tries to locate the forest type for a given location.\n *\n * @param {object} location The current location.\n * @returns {object} Includes ecogram, forest types and options.\n */\nfunction locate(location = {}) {\n  const indicator = types.indicator.map((i) => i.code);\n  const options = { forestEcoregion: Object.keys(locations), indicator };\n  const { forestEcoregion, altitudinalZone } = location;\n\n  let ecogram;\n  if (locations[forestEcoregion]) {\n    options.altitudinalZone = Object.keys(locations[forestEcoregion]);\n    if (locations[forestEcoregion][altitudinalZone]) {\n      const id = locations[forestEcoregion][altitudinalZone];\n      ecogram = ecograms[id];\n    }\n  }\n\n  let forestTypes = types.forestType;\n  if (location.forestEcoregion) {\n    // TODO: filter indicator options, depends on missing data\n  }\n  if (location.altitudinalZone) {\n    // TODO: filter indicator options, depends on missing data\n  }\n  if (location.indicators) {\n    // TODO: filter forestTypes, depends on missing data\n  }\n  if (location.forestTypeGroup) {\n    forestTypes = forestTypes.filter(\n      (ft) => ft.group[location.forestTypeGroup] === true,\n    );\n  }\n  if (location.treeLayerHeightMin) {\n    forestTypes = forestTypes.filter(\n      checkTreeLayerHeight(location.treeLayerHeightMin),\n    );\n  }\n  if (location.treeLayerHeightMax) {\n    forestTypes = forestTypes.filter(\n      checkTreeLayerHeight(location.treeLayerHeightMax),\n    );\n  }\n  if (location.coniferTreeHeightMax) {\n    forestTypes = forestTypes.filter(\n      (ft) => ft.height && ft.height[2] >= location.coniferTreeHeightMax,\n    );\n  }\n  if (location.deciduousTreeHeightMax) {\n    forestTypes = forestTypes.filter(\n      (ft) => ft.height && ft.height[3] >= location.deciduousTreeHeightMax,\n    );\n  }\n  forestTypes = forestTypes.map((ft) => ft.code);\n\n  if (ecogram) {\n    ecogram = ecogram.map((e) => {\n      const a = intersection(e.f, forestTypes).length > 0; // active\n      return { ...e, a };\n    });\n  }\n\n  return { ecogram, forestTypes, options };\n}\n\nexport default locate;\n","import projections from '../data/projections.json';\nimport types from '../data/types.json';\n\nconst fields = [\n  'forestEcoregion',\n  'altitudinalZone',\n  'forestType',\n  'slope',\n  'additional',\n  'silverFirArea',\n  'relief',\n];\nconst fieldsConcat = ['slope', 'additional', 'silverFirArea', 'relief'];\nconst concat = (x, y) =>\n  Array.from(new Set((x || []).concat(y))).sort((a, b) => a - b);\n\nconst altitudeList = types.altitudinalZone\n  .map((az) => az.code)\n  .sort((a, b) => a - b)\n  .reverse();\n\nconst getField = (field, location) => ({\n  field,\n  value: location[field],\n  values: types[field],\n});\n\nconst validate = (field, value, values) => {\n  if (value && values && values.find((v) => v.code === value) === undefined) {\n    throw new Error(`${value} for ${field} is not valid.`);\n  }\n};\nconst valueNotInOptions = (value, fieldOptions) =>\n  value && fieldOptions && fieldOptions.find((v) => v === value) === undefined;\n\nfunction projectionReducer(location, targetAltitudePointer, result) {\n  const { options } = result;\n  let projection = projections;\n  for (let i = 0; i < fields.length; i += 1) {\n    const { field, value, values } = getField(fields[i], location);\n    validate(field, value, values);\n\n    options[field] = fieldsConcat.includes(field)\n      ? concat(options[field], Object.keys(projection))\n      : options[field] || Object.keys(projection);\n\n    if (value && projection[value]) {\n      projection = projection[value];\n    } else if (projection.unknown) {\n      // Handle optional fields.\n      projection = projection.unknown;\n    } else if (valueNotInOptions(value, options[field])) {\n      // Do not return location values if no projection was found.\n      return { ...result, options };\n    } else if (fieldsConcat.includes(field)) {\n      // Fall back to first projection for secondary fields.\n      const first = Object.keys(projection)[0];\n      projection = projection[first];\n    } else {\n      // Location does not provide any more values for conditions.\n      break;\n    }\n  }\n\n  if (typeof projection === 'string') {\n    const [altitudinalZone, forestType] = projection.split(':');\n    if (altitudeList.indexOf(altitudinalZone) <= targetAltitudePointer) {\n      result.projections.push({ altitudinalZone, forestType });\n    }\n  }\n\n  return { ...result, options };\n}\n\n/**\n * This function projects the forest type for a given location into the future.\n *\n * @param {object} location The current location.\n * @param {string} targetAltitude Code for target altitudinal zone.\n * @param {object} [previousResult] Only for internal use.\n * @returns {object} Includes projections and options.\n */\nfunction project(location = {}, targetAltitude, previousResult) {\n  const altitudeIdx = altitudeList.indexOf(location.altitudinalZone);\n  const targetAltitudeIdx = altitudeList.indexOf(targetAltitude);\n  let result = previousResult || { options: {}, projections: [] };\n\n  validate('targetAltitudinalZone', targetAltitude, types.altitudinalZone);\n\n  const previous = result.projections.slice(-1)[0];\n  result = projectionReducer(location, targetAltitudeIdx, result);\n  const last = result.projections.slice(-1)[0];\n  const lastAltitudeIdx = last && altitudeList.indexOf(last.altitudinalZone);\n\n  if (previous && previous.altitudinalZone === last.altitudinalZone) {\n    // Could not find projection to targetAltitude\n    result.projections = [];\n  } else if (lastAltitudeIdx < targetAltitudeIdx) {\n    result = project({ ...location, ...last }, targetAltitude, result);\n  }\n\n  if (result && location.forestType && altitudeIdx !== -1) {\n    result.options.targetAltitudinalZone = altitudeList.slice(altitudeIdx + 1);\n  }\n\n  if (location.transitionForestType) {\n    const { transitionForestType, transitionAltitudinalZone, ...tl } = location;\n    tl.forestType = transitionForestType;\n    tl.altitudinalZone = transitionAltitudinalZone;\n    const { options, projections: tp } = project(tl, targetAltitude);\n    Object.entries(options).forEach(([k, v]) => {\n      if (fieldsConcat.includes(k)) {\n        result.options[k] = concat(result.options[k], v);\n      }\n    });\n    result.projections = result.projections.map((p) => {\n      const i = tp.findIndex((t) => t.altitudinalZone === p.altitudinalZone);\n      return { ...p, transitionForestType: tp[i] && tp[i].forestType };\n    });\n  }\n\n  // Replace alphanumeric sorting with custom sorting based on database export\n  if (result.options.forestType) {\n    result.options.forestType = types.forestType\n      .filter((ft) => result.options.forestType.includes(ft.code))\n      .map((ft) => ft.code);\n  }\n\n  return result;\n}\n\nexport default project;\n","import difference from 'lodash.difference';\nimport intersection from 'lodash.intersection';\nimport union from 'lodash.union';\nimport xor from 'lodash.xor';\n\nimport list from './list';\n\nconst removeDuplicates = (...nestedArray) => {\n  const foundItems = [];\n  return nestedArray.map((items) => {\n    const uniqueItems = difference(items, foundItems);\n    foundItems.push(...items);\n    return uniqueItems;\n  });\n};\n\n/**\n * This function recommends tree types based on a location and list of projections. Call this function with the result of the `project()` function.\n *\n * @param {object} location The current location.\n * @param {array} projections The result of the `project()` function.\n * @param {boolean} [future] Optional flag to include tree types for the future.\n * @returns {array} Nested arrays of recommended tree type codes.\n */\nfunction recommend(location = {}, projections = [], future = false) {\n  if (!location.forestType) {\n    throw new Error('location.forestType is required');\n  }\n  if (projections.reduce((c, p) => (p.forestType ? c + 1 : null), 0) < 1) {\n    throw new Error('at least 1 projected forestType is required');\n  }\n  if (future && typeof future !== 'boolean') {\n    throw new Error(`expected boolean type for future flag`);\n  }\n\n  const [today1, today2, today3, today4] = list(location);\n  const t123 = union(today1, today2, today3);\n  const p = projections.map((x) => list(x));\n  const p12 = p.map(([x1, x2]) => union(x1, x2));\n  const p3 = p.map(([, , x3]) => x3);\n  const p4 = p.map(([, , , x4]) => x4);\n  const pAll = p.map((x) => union(...x));\n  const isFuture = (x) => (future ? x : []);\n  const isMulti = (x) => (projections.length > 1 ? x : []);\n\n  return removeDuplicates(\n    intersection(t123, intersection(...p12)), //         Level 1\n    isMulti(intersection(t123, xor(...p12))), //         Level 2\n    isFuture(difference(intersection(...p12), t123)), // Level 3\n    isFuture(isMulti(difference(xor(...p12), t123))), // Level 4\n    intersection(t123, intersection(...p3)), //          Level 5\n    isMulti(intersection(t123, xor(...p3))), //          Level 6\n    isFuture(difference(intersection(...p3), t123)), //  Level 7\n    isFuture(isMulti(difference(xor(...p3), t123))), //  Level 8\n    difference(t123, union(...pAll)), //                 Level 9\n    union(today4, ...p4), //                             Level 10\n  );\n}\n\nexport default recommend;\n","import { version } from '../package.json';\n\nexport { default as info } from './info';\nexport { default as list } from './list';\nexport { default as locate } from './locate';\nexport { default as project } from './project';\nexport { default as recommend } from './recommend';\n\nexport default { version };\n"],"sourceRoot":""}