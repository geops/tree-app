{"version":3,"sources":["webpack://@geops/tree-lib/webpack/universalModuleDefinition","webpack://@geops/tree-lib/webpack/bootstrap","webpack://@geops/tree-lib/external \"lodash.intersection\"","webpack://@geops/tree-lib/external \"lodash.union\"","webpack://@geops/tree-lib/external \"lodash.difference\"","webpack://@geops/tree-lib/external \"lodash.xor\"","webpack://@geops/tree-lib/./src/info.js","webpack://@geops/tree-lib/./src/list.js","webpack://@geops/tree-lib/./src/locate.js","webpack://@geops/tree-lib/./src/project.js","webpack://@geops/tree-lib/./src/recommend.js","webpack://@geops/tree-lib/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","info","type","code","result","types","Error","find","emptyLists","byNumber","a","b","findForestType","forestType","f","nonresidents","treeType","nonresident","residents","list","location","transitionForestType","undefined","lists","entries","recommendations","transitionLists","union","intersection","sort","map","trees","filter","concat","locate","ecogram","options","forestEcoregion","keys","locations","altitudinalZone","id","ecograms","fields","fieldsConcat","x","y","Array","from","Set","altitudeList","az","reverse","getField","field","values","validate","v","valueNotInOptions","fieldOptions","project","targetAltitude","previousResult","altitudeIdx","indexOf","targetAltitudeIdx","projections","previous","slice","last","targetAltitudePointer","projection","length","includes","unknown","split","push","projectionReducer","lastAltitudeIdx","targetAltitudinalZone","transitionAltitudinalZone","tl","tp","forEach","k","findIndex","ft","removeDuplicates","foundItems","nestedArray","items","uniqueItems","difference","recommend","future","reduce","today1","today2","today3","today4","t123","p12","x1","x2","p3","p4","pAll","isFuture","isMulti","xor","version"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@geops/tree-lib\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@geops/tree-lib\"] = factory();\n\telse\n\t\troot[\"@geops/tree-lib\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","module.exports = require(\"lodash.intersection\");","module.exports = require(\"lodash.union\");","module.exports = require(\"lodash.difference\");","module.exports = require(\"lodash.xor\");","import types from '../data/types.json';\n\n/**\n * This function returns meta information about a given type and code.\n * If the code parameter is missing a list of all available codes is returned.\n * This meta information includes translations and type specific data.\n * See [data/types.json](https://github.com/geops/tree-lib/blob/master/data/types.json) for all available types and codes.\n *\n * @param {string} type A valid type.\n * @param {string} [code] A valid code for the given type.\n * @returns {object} Includes all meta information.\n */\nfunction info(type, code) {\n  let result = types[type];\n  if (!result) {\n    throw new Error(`${type} is not a valid type.`);\n  }\n\n  if (code) {\n    result = types[type].find(t => t.code === code);\n\n    if (!result) {\n      throw new Error(`${type}.${code} is not a valid code.`);\n    }\n  }\n\n  return result;\n}\n\nexport default info;\n","import intersection from 'lodash.intersection';\nimport union from 'lodash.union';\n\nimport recommendations from '../data/recommendations.json';\nimport types from '../data/types.json';\n\nconst emptyLists = [[], [], [], []];\n\nconst byNumber = (a, b) => a > b;\nconst findForestType = c => types.forestType.find(f => f.code === c);\nconst nonresidents = c => types.treeType.find(t => t.code === c).nonresident;\nconst residents = c => !types.treeType.find(t => t.code === c).nonresident;\n\n/**\n * This function lists all recommended tree types for the forest type at a given location.\n *\n * @param {object} location\n * @param {object} location.forestType Required code for forest type at current location.\n * @param {object} [location.transitionForestType] Optional code for transition forest type at current location.\n * @returns {array} Nested arrays of recommended tree type codes.\n */\nfunction list(location = {}) {\n  const { forestType, transitionForestType } = location;\n  if (!forestType) {\n    throw new Error(`forestType is missing`);\n  }\n\n  if (findForestType(forestType) === undefined) {\n    throw new Error(`${forestType} is not valid`);\n  }\n\n  const [, lists] = Object.entries(recommendations).find(\n    t => t[0] === forestType,\n  ) || [null, emptyLists];\n\n  if (transitionForestType) {\n    if (findForestType(transitionForestType) === undefined) {\n      throw new Error(`${transitionForestType} is not valid`);\n    }\n\n    const [, transitionLists] = Object.entries(recommendations).find(\n      t => t[0] === transitionForestType,\n    ) || [null, emptyLists];\n\n    lists[0] = union(\n      intersection(lists[0], transitionLists[0]),\n      intersection(lists[0], transitionLists[1]),\n    ).sort(byNumber);\n\n    lists[1] = union(\n      intersection(lists[0], transitionLists[2]),\n      intersection(lists[1], transitionLists[0]),\n      intersection(lists[1], transitionLists[1]),\n      intersection(lists[1], transitionLists[2]),\n      intersection(lists[2], transitionLists[0]),\n    ).sort(byNumber);\n\n    lists[2] = union(\n      intersection(lists[2], transitionLists[1]),\n      intersection(lists[2], transitionLists[2]),\n    ).sort(byNumber);\n\n    lists[3] = union(lists[3], transitionLists[3]).sort(byNumber);\n  }\n\n  return lists.map(trees =>\n    trees.filter(residents).concat(trees.filter(nonresidents)),\n  );\n}\n\nexport default list;\n","import ecograms from '../data/ecograms.json';\nimport locations from '../data/locations.json';\n\n/**\n * This function tries to locate the forest type for a given location.\n *\n * @param {object} location The current location.´\n * @returns {object} ...\n */\nfunction locate(location = {}) {\n  const options = { forestEcoregion: Object.keys(locations) };\n  const { forestEcoregion, altitudinalZone } = location;\n  let ecogram;\n  if (locations[forestEcoregion]) {\n    options.altitudinalZone = Object.keys(locations[forestEcoregion]);\n    if (locations[forestEcoregion][altitudinalZone]) {\n      const id = locations[forestEcoregion][altitudinalZone];\n      ecogram = ecograms[id];\n    }\n  }\n  return { ecogram, options };\n}\n\nexport default locate;\n","import projections from '../data/projections.json';\nimport types from '../data/types.json';\n\nconst fields = [\n  'forestEcoregion',\n  'altitudinalZone',\n  'forestType',\n  'slope',\n  'additional',\n  'silverFirArea',\n  'relief',\n];\nconst fieldsConcat = ['slope', 'additional', 'silverFirArea', 'relief'];\nconst concat = (x, y) =>\n  Array.from(new Set((x || []).concat(y))).sort((a, b) => a - b);\n\nconst altitudeList = types.altitudinalZone\n  .map(az => az.code)\n  .sort((a, b) => a - b)\n  .reverse();\n\nconst getField = (field, location) => ({\n  field,\n  value: location[field],\n  values: types[field],\n});\n\nconst validate = (field, value, values) => {\n  if (value && values && values.find(v => v.code === value) === undefined) {\n    throw new Error(`${value} for ${field} is not valid.`);\n  }\n};\nconst valueNotInOptions = (value, fieldOptions) =>\n  value && fieldOptions && fieldOptions.find(v => v === value) === undefined;\n\nfunction projectionReducer(location, targetAltitudePointer, result) {\n  const { options } = result;\n  let projection = projections;\n  for (let i = 0; i < fields.length; i += 1) {\n    const { field, value, values } = getField(fields[i], location);\n    validate(field, value, values);\n\n    options[field] = fieldsConcat.includes(field)\n      ? concat(options[field], Object.keys(projection))\n      : options[field] || Object.keys(projection);\n\n    if (value && projection[value]) {\n      projection = projection[value];\n    } else if (projection.unknown) {\n      // Handle optional fields.\n      projection = projection.unknown;\n    } else if (valueNotInOptions(value, options[field])) {\n      // Do not return location values if no projection was found.\n      return { ...result, options };\n    } else if (fieldsConcat.includes(field)) {\n      // Fall back to first projection for secondary fields.\n      const first = Object.keys(projection)[0];\n      projection = projection[first];\n    } else {\n      // Location does not provide any more values for conditions.\n      break;\n    }\n  }\n\n  if (typeof projection === 'string') {\n    const [altitudinalZone, forestType] = projection.split(':');\n    if (altitudeList.indexOf(altitudinalZone) <= targetAltitudePointer) {\n      result.projections.push({ altitudinalZone, forestType });\n    }\n  }\n\n  return { ...result, options };\n}\n\n/**\n * This function projects the forest type for a given location into the future.\n *\n * @param {object} location The current location.\n * @param {string} targetAltitude Code for target altitudinal zone.\n * @param {object} [previousResult] Only for internal use.\n * @returns {object} Includes projections and options.\n */\nfunction project(location = {}, targetAltitude, previousResult) {\n  const altitudeIdx = altitudeList.indexOf(location.altitudinalZone);\n  const targetAltitudeIdx = altitudeList.indexOf(targetAltitude);\n  let result = previousResult || { options: {}, projections: [] };\n\n  validate('targetAltitudinalZone', targetAltitude, types.altitudinalZone);\n\n  const previous = result.projections.slice(-1)[0];\n  result = projectionReducer(location, targetAltitudeIdx, result);\n  const last = result.projections.slice(-1)[0];\n  const lastAltitudeIdx = last && altitudeList.indexOf(last.altitudinalZone);\n\n  if (previous && previous.altitudinalZone === last.altitudinalZone) {\n    // Could not find projection to targetAltitude\n    result.projections = [];\n  } else if (lastAltitudeIdx < targetAltitudeIdx) {\n    result = project({ ...location, ...last }, targetAltitude, result);\n  }\n\n  if (result && location.forestType && altitudeIdx !== -1) {\n    result.options.targetAltitudinalZone = altitudeList.slice(altitudeIdx + 1);\n  }\n\n  if (location.transitionForestType) {\n    const { transitionForestType, transitionAltitudinalZone, ...tl } = location;\n    tl.forestType = transitionForestType;\n    tl.altitudinalZone = transitionAltitudinalZone;\n    const { options, projections: tp } = project(tl, targetAltitude);\n    Object.entries(options).forEach(([k, v]) => {\n      if (fieldsConcat.includes(k)) {\n        result.options[k] = concat(result.options[k], v);\n      }\n    });\n    result.projections = result.projections.map(p => {\n      const i = tp.findIndex(t => t.altitudinalZone === p.altitudinalZone);\n      return { ...p, transitionForestType: tp[i] && tp[i].forestType };\n    });\n  }\n\n  // Replace alphanumeric sorting with custom sorting based on database export\n  if (result.options.forestType) {\n    result.options.forestType = types.forestType\n      .filter(ft => result.options.forestType.includes(ft.code))\n      .map(ft => ft.code);\n  }\n\n  return result;\n}\n\nexport default project;\n","import difference from 'lodash.difference';\nimport intersection from 'lodash.intersection';\nimport union from 'lodash.union';\nimport xor from 'lodash.xor';\n\nimport list from './list';\n\nconst removeDuplicates = (...nestedArray) => {\n  const foundItems = [];\n  return nestedArray.map(items => {\n    const uniqueItems = difference(items, foundItems);\n    foundItems.push(...items);\n    return uniqueItems;\n  });\n};\n\n/**\n * This function recommends tree types based on a location and list of projections. Call this function with the result of the `project()` function.\n *\n * @param {object} location The current location.\n * @param {array} projections The result of the `project()` function.\n * @param {boolean} [future] Optional flag to include tree types for the future.\n * @returns {array} Nested arrays of recommended tree type codes.\n */\nfunction recommend(location = {}, projections = [], future = false) {\n  if (!location.forestType) {\n    throw new Error('location.forestType is required');\n  }\n  if (projections.reduce((c, p) => (p.forestType ? c + 1 : null), 0) < 1) {\n    throw new Error('at least 1 projected forestType is required');\n  }\n  if (future && typeof future !== 'boolean') {\n    throw new Error(`expected boolean type for future flag`);\n  }\n\n  const [today1, today2, today3, today4] = list(location);\n  const t123 = union(today1, today2, today3);\n  const p = projections.map(x => list(x));\n  const p12 = p.map(([x1, x2]) => union(x1, x2));\n  const p3 = p.map(([, , x3]) => x3);\n  const p4 = p.map(([, , , x4]) => x4);\n  const pAll = p.map(x => union(...x));\n  const isFuture = x => (future ? x : []);\n  const isMulti = x => (projections.length > 1 ? x : []);\n\n  return removeDuplicates(\n    intersection(t123, intersection(...p12)), //         Level 1\n    isMulti(intersection(t123, xor(...p12))), //         Level 2\n    isFuture(difference(intersection(...p12), t123)), // Level 3\n    isFuture(isMulti(difference(xor(...p12), t123))), // Level 4\n    intersection(t123, intersection(...p3)), //          Level 5\n    isMulti(intersection(t123, xor(...p3))), //          Level 6\n    isFuture(difference(intersection(...p3), t123)), //  Level 7\n    isFuture(isMulti(difference(xor(...p3), t123))), //  Level 8\n    difference(t123, union(...pAll)), //                 Level 9\n    union(today4, ...p4), //                             Level 10\n  );\n}\n\nexport default recommend;\n","import { version } from '../package.json';\n\nexport { default as info } from './info';\nexport { default as list } from './list';\nexport { default as locate } from './locate';\nexport { default as project } from './project';\nexport { default as recommend } from './recommend';\n\nexport default { version };\n"],"sourceRoot":""}